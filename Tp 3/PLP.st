Object subclass: #Regex	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Regex commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Regex methodsFor: 'copying' stamp: 'NicolasWalter 6/14/2018 23:03'!, aRegex^ConcatRegex pfx:self sfx: aRegex! !!Regex methodsFor: 'printing' stamp: 'Nacho 6/17/2018 18:51'!printString	^value printString.! !!Regex methodsFor: 'testing' stamp: 'Nacho 6/17/2018 18:10'!hasStar	^false.! !!Regex methodsFor: 'private' stamp: 'Nacho 6/17/2018 21:49'!length	^1.! !!Regex methodsFor: 'private' stamp: 'Nacho 6/17/2018 21:52'!length: decider	^1.! !!Regex methodsFor: 'as yet unclassified' stamp: 'Nacho 6/17/2018 18:49'!PrintString	^value printString.! !!Regex methodsFor: 'as yet unclassified' stamp: 'Nacho 6/17/2018 18:59'!star	"comment stating purpose of message"^ StarRegex new expression: self.! !!Regex methodsFor: 'logical operations' stamp: 'NicolasWalter 6/14/2018 23:00'!| aRegex^OrRegex fst:self snd: aRegex! !!Regex methodsFor: 'accessing' stamp: 'Nacho 6/17/2018 21:32'!value: aCharvalue := aChar.! !!Regex methodsFor: 'evaluating' stamp: 'Nacho 6/17/2018 21:29'!value^ value.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Regex class	instanceVariableNames: ''!!Regex class methodsFor: 'requirements' stamp: 'NicolasWalter 6/14/2018 21:15'!empty^EmptyRegex new.! !!Regex class methodsFor: 'accessing structure variables' stamp: 'NicolasWalter 6/14/2018 22:40'!doesNotUnderstand: aChar^ self new value: aChar.! !Regex subclass: #ConcatRegex	instanceVariableNames: 'prefix suffix'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!ConcatRegex methodsFor: 'printing' stamp: 'Nacho 6/17/2018 18:58'!printString	^prefix printString, suffix printString.! !!ConcatRegex methodsFor: 'accessing' stamp: 'NicolasWalter 6/14/2018 23:05'!prefix^prefix.! !!ConcatRegex methodsFor: 'accessing' stamp: 'Nacho 6/17/2018 18:31'!suffix^suffix.! !!ConcatRegex methodsFor: 'as yet unclassified' stamp: 'Nacho 6/17/2018 18:31'!prefix:aRegex suffix:anotherRegexprefix := aRegex.suffix := anotherRegex.! !!ConcatRegex methodsFor: 'private' stamp: 'Nacho 6/17/2018 22:16'!length: decider	^(prefix length: decider) + (suffix length: decider).! !!ConcatRegex methodsFor: 'testing' stamp: 'Nacho 6/17/2018 18:51'!hasStar	^prefix hasStar | suffix hasStar.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ConcatRegex class	instanceVariableNames: ''!!ConcatRegex class methodsFor: 'as yet unclassified' stamp: 'Nacho 6/17/2018 18:04'!pfx:aRegex sfx: anotherRegex^self new prefix:aRegex suffix:anotherRegex.! !Regex subclass: #EmptyRegex	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!EmptyRegex commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!EmptyRegex methodsFor: 'as yet unclassified' stamp: 'NicolasWalter 6/14/2018 21:39'!star^ self.! !!EmptyRegex methodsFor: 'private' stamp: 'Nacho 6/17/2018 21:51'!length	^0.! !!EmptyRegex methodsFor: 'private' stamp: 'Nacho 6/17/2018 21:52'!length: decider	^0.! !!EmptyRegex methodsFor: 'printing' stamp: 'Nacho 6/17/2018 18:37'!printString	^'empty'! !Regex subclass: #OrRegex	instanceVariableNames: 'first second'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!OrRegex methodsFor: 'as yet unclassified' stamp: 'Nacho 6/17/2018 18:03'!first^first.! !!OrRegex methodsFor: 'as yet unclassified' stamp: 'Nacho 6/17/2018 19:04'!second^second.! !!OrRegex methodsFor: 'private' stamp: 'Nacho 6/17/2018 21:55'!length: decider	| firstLength secondLength |		firstLength  := first  length: decider.	secondLength := second length: decider.			^decider value:firstLength value: secondLength.! !!OrRegex methodsFor: 'accessing' stamp: 'NicolasWalter 6/14/2018 22:59'!first: aRegex second: anotherRegex.first := aRegex.second := anotherRegex.! !!OrRegex methodsFor: 'testing' stamp: 'Nacho 6/17/2018 18:06'!hasStar	^first hasStar | second hasStar.! !!OrRegex methodsFor: 'printing' stamp: 'Nacho 6/17/2018 18:34'!printString	^'(', first printString, '|', second printString, ')'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OrRegex class	instanceVariableNames: ''!!OrRegex class methodsFor: 'as yet unclassified' stamp: 'NicolasWalter 6/14/2018 22:58'!fst:aRegex snd:anotherRegex^self new first:aRegex second:anotherRegex.! !Regex subclass: #StarRegex	instanceVariableNames: 'expression'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!StarRegex methodsFor: 'testing' stamp: 'Nacho 6/17/2018 18:05'!hasStar	^true.! !!StarRegex methodsFor: 'private' stamp: 'Nacho 6/17/2018 22:13'!length: decider	| expressionLength |		expressionLength := expression length: decider.		expressionLength  > 0 		ifTrue: [			| partialResult |			partialResult := decider value: expressionLength value: (Float infinity).			^decider value: 0 value: partialResult.		]		ifFalse: [^0.].! !!StarRegex methodsFor: 'accessing' stamp: 'Nacho 6/17/2018 19:05'!expression^expression.! !!StarRegex methodsFor: 'accessing' stamp: 'Nacho 6/17/2018 19:04'!expression: anExpression	expression := anExpression.! !!StarRegex methodsFor: 'printing' stamp: 'Nacho 6/17/2018 18:58'!printString	^'(', expression printString, ')', '*'.! !TestCase subclass: #TestEj1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!TestEj1 methodsFor: 'tests' stamp: 'Nacho 6/17/2018 21:28'!test1_1_regex	|e a b aaa a_b ab|		e := Regex empty.	a := Regex a.	b := Regex b.	aaa := a star.	a_b := a | b.	ab := a , b.		self assert: e isNotNil.	self assert: a isNotNil.	self assert: b isNotNil.	self assert: a_b isNotNil.	self assert: aaa isNotNil.	self assert: ab isNotNil.		"Si los values son Simbolos como se crean on the fly cuando se agregan?" 	self assert: a value equals: $a.	self assert: b value equals: $b.	self assert: aaa value equals: a.	self assert: a_b first equals: a.	self assert: a_b second equals: b.	self assert: ab prefix equals: a.	self assert: ab suffix equals: b.! !TestCase subclass: #TestEj2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!TestEj2 methodsFor: 'tests' stamp: 'Nacho 6/17/2018 18:48'!test2_2_printString	|e a b c aaa abc b_c aaab_c|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.		aaa := a star.	abc := a , b , c.	b_c := b | c.	aaab_c := aaa , b_c.		self assert: e printString equals: 'empty'.	self assert: a printString equals: 'a'.	self assert: abc printString equals: 'abc'.	self assert: b_c printString equals: '(b|c)'.	self assert: aaa printString equals: '(a)*'.	self assert: aaab_c printString equals: '(a)*(b|c)'.! !!TestEj2 methodsFor: 'tests' stamp: 'Nacho 6/17/2018 18:32'!test2_1_hasStar	|e a b c aaa b_c aaab_c|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.		aaa := a star.	b_c := b | c.	aaab_c := aaa , b_c.		self assert: aaa hasStar.	self assert: aaab_c hasStar.	self assert: e hasStar not.	self assert: a hasStar not.	self assert: b_c hasStar not.! !TestCase subclass: #TestEj3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!TestEj3 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:09'!test3_2_maxLength	|e a b c aaa b_c aaab_c max|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	b_c := b | c.	aaab_c := aaa , b_c.	max := [:x :y | x max: y].		self assert: (aaa length: max) isInfinite.	self assert: (aaab_c length: max) isInfinite.	self assert: (e length: max) equals: 0.	self assert: (a length: max) equals: 1.	self assert: (b_c length: max) equals: 1.! !!TestEj3 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:10'!test3_1_minLength	|e a b c aaa b_c aaab_c min|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	b_c := b | c.	aaab_c := aaa , b_c.	min := [:x :y | x min: y].		self assert: (aaa length: min) equals: 0.	self assert: (aaab_c length: min) equals: 1.	self assert: (e length: min) equals: 0.	self assert: (a length: min) equals: 1.	self assert: (b_c length: min) equals: 1.! !TestCase subclass: #TestEj4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/11/2018 22:32'!test4_6_match	|a b c b_c aaa aaab_c bbbb|		a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	b_c := b | c.	aaab_c := aaa , b_c.	bbbb := b star , b.		self assert: (aaab_c match: 'b').	self assert: (aaab_c match: 'c').	self assert: (aaab_c match: 'ab').	self assert: (aaab_c match: 'ac').	self assert: (aaab_c match: 'aab').	self assert: (aaab_c match: 'aaac').	self assert: (bbbb match: 'b').	self assert: (bbbb match: 'bb').	self assert: (bbbb match: 'bbb').	self assert: (bbbb match: '') not.	self assert: (aaab_c match: '') not.	self assert: (aaab_c match: 'a') not.	self assert: (aaab_c match: 'aa') not.	self assert: (aaab_c match: 'aaa') not.	self assert: (aaab_c match: 'ba') not.	self assert: (aaab_c match: 'ca') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:06'!test4_1_empty	|e|		e := Regex empty.		self assert: (e match: '').	self assert: (e match: 'a') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:08'!test4_5_star	|a aaa|		a := Regex a.	aaa := a star.		self assert: (aaa match: '').	self assert: (aaa match: 'a').	self assert: (aaa match: 'aa').	self assert: (aaa match: ('a' repeat: (Random new nextInt: 10))).	self assert: (aaa match: 'b') not.	self assert: (aaa match: 'ab') not.	self assert: (aaa match: 'aab') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:06'!test4_2_char	|a b|		a := Regex a.	b := Regex b.		self assert: (a match: 'a').	self assert: (a match: '') not.	self assert: (a match: 'b') not.	self assert: (a match: 'ab') not.		self assert: (b match: 'b').	self assert: (b match: '') not.	self assert: (b match: 'a') not.	self assert: (b match: 'ba') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:07'!test4_4_or	|a b a_b|		a := Regex a.	b := Regex b.	a_b := a | b.		self assert: (a_b match: 'a').	self assert: (a_b match: 'b').	self assert: (a_b match: '') not.	self assert: (a_b match: 'ab') not.	self assert: (a_b match: 'ba') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:06'!test4_3_concat	|a b ab|		a := Regex a.	b := Regex b.	ab := a , b.		self assert: (ab match: 'ab').	self assert: (ab match: '') not.	self assert: (ab match: 'a') not.	self assert: (ab match: 'aba') not.! !